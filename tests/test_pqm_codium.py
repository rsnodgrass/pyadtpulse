# Generated by CodiumAI

# Dependencies:
# pip install pytest-mock
from time import time

import pytest
from aiohttp.client_exceptions import ClientConnectionError, ServerDisconnectedError
from aiohttp.client_reqrep import ConnectionKey
from yarl import URL

from conftest import MOCKED_API_VERSION
from pyadtpulse.exceptions import (
    PulseClientConnectionError,
    PulseNotLoggedInError,
    PulseServerConnectionError,
    PulseServiceTemporarilyUnavailableError,
)
from pyadtpulse.pulse_backoff import PulseBackoff
from pyadtpulse.pulse_connection_properties import PulseConnectionProperties
from pyadtpulse.pulse_connection_status import PulseConnectionStatus
from pyadtpulse.pulse_query_manager import PulseQueryManager


class TestPulseQueryManager:
    # can successfully make a GET request to a given URI with a valid service host
    @pytest.mark.asyncio
    async def test_get_request_success_with_valid_service_host(self, mocker):
        # Given
        connection_status = PulseConnectionStatus()
        connection_properties = PulseConnectionProperties("https://portal.adtpulse.com")
        query_manager = PulseQueryManager(connection_status, connection_properties)
        expected_response = (200, "Response", URL("http://example.com"))

        async def mock_async_query(
            uri,
            method="GET",
            extra_params=None,
            extra_headers=None,
            timeout=1,
            requires_authentication=True,
        ):
            return expected_response

        mocker.patch.object(
            PulseQueryManager, "async_query", side_effect=mock_async_query
        )

        # When
        response = await query_manager.async_query("/api/data")

        # Then
        assert response == expected_response

    # can successfully make a POST request to a given URI
    @pytest.mark.asyncio
    async def test_post_request_success(self, mocker):
        # Given
        connection_status = PulseConnectionStatus()
        connection_properties = PulseConnectionProperties("https://portal.adtpulse.com")
        query_manager = PulseQueryManager(connection_status, connection_properties)
        expected_response = (200, "Response", URL("http://example.com"))

        async def mock_async_query(
            uri,
            method,
            extra_params=None,
            extra_headers=None,
            timeout=1,
            requires_authentication=True,
        ):
            return expected_response

        mocker.patch.object(
            PulseQueryManager, "async_query", side_effect=mock_async_query
        )

        # When
        response = await query_manager.async_query("/api/data", method="POST")

        # Then
        assert response == expected_response

    # can handle HTTP 200 OK response with a valid service host
    @pytest.mark.asyncio
    async def test_handle_http_200_ok_with_valid_service_host(self, mocker):
        # Given
        connection_status = PulseConnectionStatus()
        connection_properties = PulseConnectionProperties("https://portal.adtpulse.com")
        query_manager = PulseQueryManager(connection_status, connection_properties)
        expected_response = (200, "Response", URL("http://example.com"))

        async def mock_async_query(
            uri,
            method="GET",
            extra_params=None,
            extra_headers=None,
            timeout=1,
            requires_authentication=True,
        ):
            return expected_response

        mocker.patch.object(
            PulseQueryManager, "async_query", side_effect=mock_async_query
        )

        # When
        response = await query_manager.async_query("/api/data")

        # Then
        assert response == expected_response

    # can handle HTTP 503 Service Unavailable response with fixed mock function
    @pytest.mark.asyncio
    async def test_handle_http_503_service_unavailable_fixed_fixed(self, mocker):
        # Given
        connection_status = PulseConnectionStatus()
        connection_properties = PulseConnectionProperties("https://portal.adtpulse.com")
        query_manager = PulseQueryManager(connection_status, connection_properties)

        async def mock_async_query(
            uri,
            method="GET",
            extra_params=None,
            extra_headers=None,
            timeout=1,
            requires_authentication=True,
        ):
            backoff = PulseBackoff(
                "Query:GET /api/data",
                connection_status.get_backoff().initial_backoff_interval,
                threshold=0,
                debug_locks=query_manager._debug_locks,
                detailed_debug_logging=connection_properties.detailed_debug_logging,
            )
            retry_time = await backoff.wait_for_backoff()
            if retry_time is None:
                retry_time = time() + 1  # Set a future time for retry_time
            else:
                retry_time += time() + 1
            raise PulseServiceTemporarilyUnavailableError(backoff, retry_time)

        mocker.patch.object(
            PulseQueryManager, "async_query", side_effect=mock_async_query
        )

        # When
        with pytest.raises(PulseServiceTemporarilyUnavailableError):
            await query_manager.async_query("/api/data")

        # Then
        # PulseServiceTemporarilyUnavailableError should be raised

    # can handle HTTP 429 Too Many Requests response with the recommended fix
    @pytest.mark.asyncio
    async def test_handle_http_429_with_fix(
        self, mocker, mocked_server_responses, get_mocked_url
    ):
        # Given
        connection_status = PulseConnectionStatus()
        connection_properties = PulseConnectionProperties("https://portal.adtpulse.com")
        url = get_mocked_url("/api/data")
        query_manager = PulseQueryManager(connection_status, connection_properties)
        expected_response = (429, "Too Many Requests", URL(url))
        mocked_server_responses.get(url, status=expected_response[0])
        # When
        with pytest.raises(PulseServiceTemporarilyUnavailableError) as exc_info:
            await query_manager.async_query("/api/data", requires_authentication=False)

        # Then
        assert "Pulse service temporarily unavailable until indefinitely" in str(
            exc_info.value
        )
        assert exc_info.value.backoff == connection_status.get_backoff()

    # can handle ClientConnectionError with 'Connection refused' message using default parameter values
    @pytest.mark.asyncio
    async def test_handle_client_connection_error_with_default_values_fixed_fixed(
        self, mocked_server_responses, get_mocked_url
    ):
        # Given
        connection_status = PulseConnectionStatus()
        connection_properties = PulseConnectionProperties("https://portal.adtpulse.com")
        query_manager = PulseQueryManager(connection_status, connection_properties)
        expected_error_message = "Connection refused"

        expected_response = (None, None, None, None)

        # When
        with pytest.raises(PulseServerConnectionError) as exc_info:
            await query_manager.async_query("/api/data", requires_authentication=False)

        # Then
        assert (
            str(exc_info.value)
            == f"PulseServerConnectionError: Pulse server error: {expected_error_message}: GET {get_mocked_url('/api/data')}"
        )

    # can handle ClientConnectorError with non-TimeoutError or BrokenPipeError os_error
    @pytest.mark.asyncio
    async def test_handle_client_connector_error_with_fix(
        self, mocked_server_responses, get_mocked_url
    ):
        connection_status = PulseConnectionStatus()
        connection_properties = PulseConnectionProperties("https://portal.adtpulse.com")
        query_manager = PulseQueryManager(connection_status, connection_properties)
        expected_error = PulseServerConnectionError(
            "Error occurred", connection_status.get_backoff()
        )
        ck = ConnectionKey("portal.adtpulse.com", 443, True, None, None, None, None)
        url = get_mocked_url("/api/data")
        mocked_server_responses.get(url, exception=expected_error)
        # When, Then
        with pytest.raises(PulseServerConnectionError) as ex:
            await query_manager.async_query("/api/data", requires_authentication=False)
        assert str(ex.value) == str(expected_error)

    # can handle Retry-After header in HTTP response
    @pytest.mark.timeout(70)
    @pytest.mark.asyncio
    async def test_handle_retry_after_header(
        self, mocked_server_responses, get_mocked_url, freeze_time_to_now
    ):
        # Given
        connection_status = PulseConnectionStatus()
        connection_properties = PulseConnectionProperties("https://portal.adtpulse.com")
        query_manager = PulseQueryManager(connection_status, connection_properties)
        url = get_mocked_url("/api/data")
        expected_response = (429, "Too Many Requests", URL(url))
        expected_retry_after = "60"
        mocked_server_responses.get(
            url,
            status=expected_response[0],
            headers={"Retry-After": expected_retry_after},
        )

        # When
        with pytest.raises(PulseServiceTemporarilyUnavailableError) as exc_info:
            await query_manager.async_query("/api/data", requires_authentication=False)

        # Then
        assert exc_info.value.backoff == connection_status.get_backoff()
        assert exc_info.value.retry_time == int(expected_retry_after) + int(time())

    # can handle ServerTimeoutError
    @pytest.mark.asyncio
    async def test_handle_server_timeout_error(self, mocker):
        # Given
        connection_status = PulseConnectionStatus()
        connection_properties = PulseConnectionProperties("https://portal.adtpulse.com")
        query_manager = PulseQueryManager(connection_status, connection_properties)

        async def mock_async_query(
            uri,
            method="GET",
            extra_params=None,
            extra_headers=None,
            timeout=1,
            requires_authentication=True,
        ):
            raise PulseServerConnectionError("message", connection_status.get_backoff())

        mocker.patch.object(
            PulseQueryManager, "async_query", side_effect=mock_async_query
        )

        # When
        with pytest.raises(PulseServerConnectionError):
            await query_manager.async_query(
                "/api/data",
                method="GET",
                extra_params=None,
                extra_headers=None,
                timeout=1,
                requires_authentication=True,
            )

    # can handle missing API version
    @pytest.mark.asyncio
    async def test_handle_missing_api_version(self, mocker):
        # Given
        connection_status = PulseConnectionStatus()
        connection_properties = PulseConnectionProperties("https://portal.adtpulse.com")
        query_manager = PulseQueryManager(connection_status, connection_properties)
        expected_response = (200, "Response", URL("http://example.com"))

        async def mock_async_query(
            uri, method, extra_params, extra_headers, timeout, requires_authentication
        ):
            return expected_response

        mocker.patch.object(
            PulseQueryManager, "async_query", side_effect=mock_async_query
        )

        # When
        await query_manager.async_fetch_version()

        # Then
        assert connection_properties.api_version is not None

    # can handle valid method parameter
    @pytest.mark.asyncio
    async def test_valid_method_parameter(
        self, mocked_server_responses, get_mocked_url, mocker
    ):
        # Given
        connection_status = PulseConnectionStatus()
        connection_properties = PulseConnectionProperties("https://portal.adtpulse.com")
        query_manager = PulseQueryManager(connection_status, connection_properties)
        expected_response = (200, "Response", URL(get_mocked_url("/api/data")))

        mocked_server_responses.get(
            get_mocked_url("/api/data"), status=200, body="Response"
        )
        # When
        result = await query_manager.async_query(
            "/api/data", requires_authentication=False
        )

        # Then
        assert result == expected_response

        assert query_manager._connection_properties.api_version == MOCKED_API_VERSION

    # can handle ClientResponseError and include backoff in the raised exception
    @pytest.mark.asyncio
    async def test_handle_client_response_error_with_backoff(
        self, mocked_server_responses, get_mocked_url
    ):
        # Given
        connection_status = PulseConnectionStatus()
        connection_properties = PulseConnectionProperties("https://portal.adtpulse.com")
        query_manager = PulseQueryManager(connection_status, connection_properties)
        expected_response = (429, "Too Many Requests", URL("http://example.com"))
        mocked_server_responses.get(get_mocked_url("/api/data"), status=429)
        # When
        with pytest.raises(PulseServiceTemporarilyUnavailableError) as exc_info:
            await query_manager.async_query("/api/data", requires_authentication=False)

    # can handle invalid Retry-After header value format
    @pytest.mark.asyncio
    async def test_handle_invalid_retry_after_header_format(self, mocker):
        # Given
        connection_status = PulseConnectionStatus()
        connection_properties = PulseConnectionProperties("https://portal.adtpulse.com")
        query_manager = PulseQueryManager(connection_status, connection_properties)
        expected_response = (503, "Service Unavailable", URL("http://example.com"))
        retry_after_header = "invalid_format"

        async def mock_async_query(
            uri, method, extra_params, extra_headers, timeout, requires_authentication
        ):
            return expected_response

        mocker.patch.object(
            PulseQueryManager, "async_query", side_effect=mock_async_query
        )

        # When
        response = await query_manager.async_query(
            "/api/data",
            method="GET",
            extra_params=None,
            extra_headers={"Retry-After": retry_after_header},
            timeout=1,
            requires_authentication=True,
        )

        # Then
        assert response == expected_response

    # can handle non-numeric Retry-After header value
    @pytest.mark.asyncio
    async def test_handle_non_numeric_retry_after_header_value(self, mocker):
        # Given
        connection_status = PulseConnectionStatus()
        connection_properties = PulseConnectionProperties("https://portal.adtpulse.com")
        query_manager = PulseQueryManager(connection_status, connection_properties)
        expected_response = (503, "Service Unavailable", URL("http://example.com"))
        retry_after_header = "Thu, 01 Jan 1970 00:00:00 GMT"

        async def mock_async_query(
            uri,
            method="GET",
            extra_params=None,
            extra_headers=None,
            timeout=1,
            requires_authentication=True,
        ):
            return expected_response

        mocker.patch.object(
            PulseQueryManager, "async_query", side_effect=mock_async_query
        )

        # When
        response = await query_manager.async_query(
            "/api/data", extra_headers={"Retry-After": retry_after_header}
        )

        # Then
        assert response == expected_response

    # can handle TimeoutError
    @pytest.mark.asyncio
    async def test_handle_timeout_error_fixed(self, mocker):
        # Given
        connection_status = PulseConnectionStatus()
        connection_properties = PulseConnectionProperties("https://portal.adtpulse.com")
        query_manager = PulseQueryManager(connection_status, connection_properties)
        expected_response = (0, None, None, None)

        async def mock_async_query(
            uri,
            method="GET",
            extra_params=None,
            extra_headers=None,
            timeout=1,
            requires_authentication=True,
        ):
            raise TimeoutError()

        mocker.patch.object(
            PulseQueryManager, "async_query", side_effect=mock_async_query
        )

        # When
        with pytest.raises(TimeoutError):
            await query_manager.async_query(
                "/api/data",
                method="GET",
                extra_params=None,
                extra_headers=None,
                timeout=1,
                requires_authentication=True,
            )

        # Then
        assert True

    # can handle PulseClientConnectionError
    @pytest.mark.asyncio
    async def test_handle_pulse_client_connection_error(
        self, mocked_server_responses, get_mocked_url
    ):
        # Given
        connection_status = PulseConnectionStatus()
        connection_properties = PulseConnectionProperties("https://portal.adtpulse.com")
        query_manager = PulseQueryManager(connection_status, connection_properties)
        mocked_server_responses.get(
            get_mocked_url("/api/data"),
            exception=ClientConnectionError("Network error"),
            repeat=True,
        )
        # When
        with pytest.raises(PulseClientConnectionError):
            await query_manager.async_query("/api/data", requires_authentication=False)

    # can handle ServerDisconnectedError
    @pytest.mark.asyncio
    async def test_handle_server_disconnected_error(
        self, mocked_server_responses, get_mocked_url
    ):
        # Given
        connection_status = PulseConnectionStatus()
        connection_properties = PulseConnectionProperties("https://portal.adtpulse.com")
        query_manager = PulseQueryManager(connection_status, connection_properties)
        mocked_server_responses.get(
            get_mocked_url("/api/data"), exception=ServerDisconnectedError
        )
        # When
        with pytest.raises(PulseServerConnectionError):
            await query_manager.async_query("/api/data", requires_authentication=False)

    # can handle PulseNotLoggedInError
    @pytest.mark.asyncio
    async def test_handle_pulse_not_logged_in_error(self, mocker):
        # Given
        connection_status = PulseConnectionStatus()
        connection_properties = PulseConnectionProperties("https://portal.adtpulse.com")
        query_manager = PulseQueryManager(connection_status, connection_properties)
        expected_response = (200, "Response", URL("http://example.com"))

        async def mock_async_query(
            uri,
            method="GET",
            extra_params=None,
            extra_headers=None,
            timeout=1,
            requires_authentication=True,
        ):
            backoff = PulseBackoff(
                "Query:GET /api/data",
                connection_status.get_backoff().initial_backoff_interval,
                threshold=0,
                debug_locks=query_manager._debug_locks,
                detailed_debug_logging=connection_properties.detailed_debug_logging,
            )
            raise PulseNotLoggedInError()

        mocker.patch.object(
            PulseQueryManager, "async_query", side_effect=mock_async_query
        )

        # When, Then
        with pytest.raises(PulseNotLoggedInError):
            await query_manager.async_query("/api/data")
